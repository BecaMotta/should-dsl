>>> from should_dsl import should, should_not

>>> class Box(object):
...     def __init__(self):
...         self.items = []
...     def add_items(self, *items):
...         for item in items:
...             self.items.append(item)
...     def item_count(self):
...         return len(self.items)

>>> box = Box()
>>> (lambda: box.add_items(1)) |should| change(lambda: box.item_count())
True
>>> (lambda: box.add_items(1)) |should_not| change(lambda: box.item_count())
Traceback (most recent call last):
    ...
ShouldNotSatisfied: should not have changed, but did change from 1 to 2
>>> (lambda: 0) |should| change(lambda: box.item_count())
Traceback (most recent call last):
    ...
ShouldNotSatisfied: result should have changed, but is still 2


>>> (box.add_items, 1) |should| change(box.item_count)
True
>>> (box.add_items, 1) |should| change(box.items)
Traceback (most recent call last):
    ...
TypeError: parameter passed to change must be a callable or a iterable having a callable as its first element
>>> (1, box.add_items) |should| change(box.item_count)
Traceback (most recent call last):
    ...
TypeError: parameter passed to change must be a callable or a iterable having a callable as its first element

